Задания.

1. Прочитать данные из файла, заменить вхождения одной последовательности (исходной на заменяющую) байт на другую, результат записать в другой файл. Файл и последовательности произвольного размера и произвольного содержимого.
Запрещено считывать из файла каждый байт более одного раза.
Имена файлов и последовательности (исходную и заменяющую) получать из аргументов командной строки.
Чтение из файла осуществлять блоками размером 512 байт (для работы с файлами использовать функции fopen ,fread, fwrite, fclose).
Пример. Если в тексте "adfkasddkjadfkdaqwed" заменить "ad" на "12345", то получим "12345fkasddkj12345fkdaqwed".

Условия для оценки 3
1) Можно считать, что размер исходной последовательности не больше 512 байт.
2) В памяти нельзя хранить из файла данных одновременно больше чем 1024 байта.

Условия для оценки 4
1) В памяти нельзя хранить из файла данных одновременно больше чем 512 байт.




2. Программа вывода содержимого файла в шестнадцатиричном виде.

Условия для оценки 3.

Программа должна поддерживать опции командной строки (передаются в любом порядке):
-i file_name	имя выводимого файла
-o offset		смещение от начала файла, с которого выводится содержимое (если не задано, то выводить с начала файла)
-l size			количество выводимых из файла байт (если не задано, то выводить всё)
-g byte|word|dword	какими кусочками выводить данные: 1 байт, 2 байта, 4 байта (если не задано, то 1 байт)
-n count		количество кусочков, выводимых в одной строке (если не задано, то 16)

В каждой строке программа должна выводить смещение от начала файла, указанное количество кусочков информации в шестнадцатиричном виде. Если кусочек равен байту (т.е. опция -n byte), то в конце строки после вывода данных в шестнадцатиричном виде выводить их же в символьном виде (для каких это возможно).

Осуществлять преобразования байт файла в шестнадцатиричные символы самостоятельно. Т.е. с помощью printf можно выводить только символы (с помощью %c), соответствующие байтам содержимого файла (которые необходимо самостоятельно перевести в символы). Смещение можно выводить с помощью printf в виде числа (через %x).

Для разбора аргументов командной строки использовать функцию getopt. Настроенный шаблон для задания прилагается (template\3).

Пример использования.
Пусть содержимое файла file (последовательность байт в шестнадцатиричном виде):
0x10 0x11 0x12 0x13 0xFA 0xFB 0xFC 0xFD 0x00 0x20 0x30 0x40 0x41 0x42 0x31 0x32 0x33 0x34

./prog -i file
00000000  10 11 12 13 FA FB FC FD 00 20 30 40 41 42 31 32 | ........ 0@ABC12
00000010  33 34                                           | 34

./prog -o 2 -g dword -n 2 -l 12 -i file
00000002  FBFA1312 2000FDFC
0000000A  42414030

./prog -o 2 -l 11 -g dword -n 2 -i file
00000002  FBFA1312 2000FDFC
0000000A  00414030


Условия для оценки 4.
Дополнительно поддерживать опцию
-f format_str	указание форматной строки, определяющей формат вывода каждой строки.
Форматная строка состоит из обычных символов, спецсимволов и спецификаторов.
Обычными символами считаются все символы, которые не являются спецсимволами или частью спецификатора.
Спецсимволами являются символы '\' и '%', которые меняют интерпретацию следующего за ними символа. Поддерживать следующие последовательности:
"\n" - байт перевода строки (0x0A).
"\r" - байт возврата каретки (0x0D).
"\t" - байт табуляции (0x09).
"\\" - символ '\'.
Спецификаторы соответствуют выводимым кусочкам (их количество в строке и размер задаётся параметрами -n, -g) файла.
Спецификаторы имеют вид:
%i - индекс текущей строки
%n - смещение текущей строки
%ix - вывод i-го кусочка в шестнадцатиричном виде
%ic - вывод i-го кусочка в символьном виде (1, 2 или 4 символа в зависимости от размера кусочка)

./prog -i file -f "%i %n %0x %1x %2x %3x %4x %5x %6x %7x %8x %9x %10x %11x %12x %13x %14x %15x | %0c%1c%2c%3c%4c%5c%6c%7c%8c%9c%10c%11c%12c%13c%14c%15c\n"
0 00000000 10 11 12 13 FA FB FC FD 00 20 30 40 41 42 31 32 | ........ 0@ABC12
1 00000010 33 34                                           | 34

./prog -i file -o 2 -g word -n 3 -f "%i x0 = %0x\t\tx2 = %2x(%2с)\n"
0 x0 = 1312		x2 = FDFC(..)
1 x0 = 2000		x2 = 4241(AB)
2 x0 = 3231		x2 = 0000(..)




3. Реализовать функции преобразования из числа в строку и из строки в число.

Условия для оценки 3.

При реализации алгоритмов преобразований не должны использоваться никакие библиотечные функции. Нельзя использовать типы данных размером больше int (например, long long).

1) Функция
int strtoi (const char *str, char **p, int *ret)
анализирует строку str, преобразует её в число типа int, которое возвращается по указателю ret. В случае успеха функция возвращает 1, в случае ошибки - 0. Функция должна проверять корректность символов в строке. По указателю p (если он не нулевой) возвращается указатель на первый символ строки, содержащий некорректное значение.
Ошибкой считается случай задания строкой числа (до нулевого символа или до первого некорректного символа), не помещающегося в int. Т.е. функция должна обнаруживать переполнение int и возвращать в этом случае 0.
Систему счисления необходимо определять из вида строки:
если строка начинается с "0x", то шестнадцатиричная;
если строка начинается с "0", то восьмиричная;
если строка начинается с "b", то двоичная;
в остальных случаях десятичная.

2) Функция
int my_itoa (char *buf, int bufSize, int value, int p)
переводит переданное число value в строку символов в p-ичной системе счисления, которую записывает в буфер buf размером bufSize. Возвращает количество записанных в буфер символов (не больше bufSize). Если аргумент buf равен нулю, то необходимо подсчитать необходимый размер буфера и вернуть его.

Написать программу, демонстрирующую работу этих функций.




4. Написать программу генерации случайных паролей.

Условия для оценки 3.

Программа должна самостоятельно обрабатывать аргументы командной строки и интепретировать следующие опции:
-m1	минимальная длина пароля
-m2	максимальная длина пароля
-n  длина пароля
-c  количество паролей
-a	алфавит символов
-C [aADS]	набор символов (указывается один или несколько символов из множества {a, A, D, S}),
         a - маленькие латинские символы,
         A - большие латинские символы,
         D - цифры,
         S - спецсимволы.
Проверять корректность опций и аргументов опций (одни и те же опции не должны повторяться,
в качестве длины должна передаваться числовая строка и т.д.).
Опции могут передаваться в произвольном порядке.
Могут встречаться другие опции, которые следует игнорировать.
Если есть опция -m1 должна быть опция -m2. Опции -m1,-m2 и -n не совместимы вместе
(выдавать соответствующее сообщение).
Опции -a и -C не совместимы вместе (выдавать соответствующее сообщение).
Пример передачи корректных опций:
# generate.exe -s -m1 10 -i -m2 20 -CaD
# generate.exe -m3 -n 10 -a 123456


Условия для оценки 4.

Дополнительно предусмотреть способ передачи через аргументы (завести какую-нибудь ещё опцию) 
вероятности появления символов в пароле. Если набор символов задается через опцию -C, 
то для каждого из указанных символов aADS указывать вероятность (это будет вероятность выбора символа из этого множества). 
Если набор задается через опцию -a, то вероятность должна указываться для отдельных символов алфавита. 
Если для каких-то символов или букв aADS вероятность не указана, 
то оставшуюся вероятность равномерно делить между оставшимися символами алфавита (для опции -a) 
или множествами символов (для опции -C).
