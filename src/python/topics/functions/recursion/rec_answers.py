STR_SOMETHING = ""
STR_SOMETHING_ELSE = ""
INT_SOMETHING = 0
INT_SOMETHING_ELSE = 0
LIST_SOMETHING = []
LIST_SOMETHING_ELSE = []

'''
	Структурная индукция на списках.

	Добро пожаловать в модуль, посвященный решению различных
	задач на строках и списках с помощью рекурсии. Строки тоже
	можно воспринимать как список символов и букв и работать похожим образом.

	Чтобы потренировать навыки рекурсии, в этом модуле
	придется полностью отказаться от циклов, но ограничив инструментарий,
	мы расширим наш кругозор и интуицию.

	Для объяснения принципа решения таких задач, нужно понять,
	Что рекурсивная функция принимает список в качестве аргумента.

	Если список пустой, то есть [], то проблема минимально сложна,
	а значит ее можно сразу решить.

	Иначе, если в списке есть хотя бы один элемент, тогда
	можно взять первый элемент, обработать его, а оставшиеся элементы
	передать исходной функции, применив рекурсию. Вспоминаем, что функция
	принимает список, а оставшиеся элементы - это тоже список.

	См иллюстрацию:

		1) Попробуем реализовать функцию нахождения длины списка, rec_len

			rec_len принимает список, и возвращает целое число. list --> int

			 								  распаковка :)
                                                   |
			   									   V
		2) Рассмотрим исходный сисок, как [голова, *хвост]

											хвост(tail)
										   	     |	
							    	 голова(head)|
										   |     |
			   							   V     V
		3) Например: Список [a, b, c] ---> a и [b, c]

		4) За каждый элемент длина списка увеичивается на 1.
		   Таким образом если удалось взять голову, то длина равна как минимум 1.
		   Но у нас же есть еще хвост неопределенной длины. Как же ее определить?
		   Нужно отправить хвост на вход самой функции rec_len

		   rec_len(some_list) = 1 + rec_len(tail(some_list))

		   Вот мы и получили общий случай решения проблемы.
		   
		5) Но что делать, если голову взять нельзя?
		   Ведь забирая из списка по одному элементу, мы рано или поздно
		   упремся в этот случай, когда список окажется пустым.

		   Этот случай называется базовым или его также называют терминальным.
		   Его нужно обрабатывать по-особому.

		   В случае с функцией rec_len, длина пустого списка равна 0 и на этом все.

		   rec_len([]) = 0

		6) Таким образом используя синтаксис питона, можно написать следующую функцию:

			def rec_len(some_list):
				if base_case(some_list):
					return 0
				else:
					return 1 + rec_len(tail(some_list))

		7) Обратите внимание на использование вспомогательных функций tail и base_case.
		   есть еще функция head, которая не так важна для rec_len, но тоже будет полезна.
		   Ниже приведены определения этих функций и они рекомендованы для использования
		   в задачах этого модуля.
'''
def base_case(indexable):
	return indexable == [] or indexable == ""


def head(indexable):
	if base_case(indexable):
		raise ValueError("Невозможно взять голову у пустого списка")
	return indexable[0]


def tail(indexable):
	if base_case(indexable):
		raise ValueError("Невозможно взять хвост у пустого списка")
	return indexable[1:]

'''
	Нахождение длины списка или строки:
'''
def rec_len(some_list):
	if base_case(some_list):
		return 0
	else:
		return 1 + rec_len(tail(some_list))


'''
	Задача 1. Напишите рекурсивную функцию rec_all,
	которая бы являлась полнымэквивалентом функции all

	На вход подается список, и my_all вернет True, если
	все элементы в списке логически соответствуют True.

	Подсказка: Можно переводить элементы списка в булево
	значение с помощь. функции bool().

	Подсказка: Если данный список пуст, в нем нет False-элементов,
	то есть ложных утверждений, поэтому результатом
	функции my_all от пустого списка будет True.
'''
def rec_all(values):
	if base_case(values):
		return True
	else:
		return bool(head(values)) and rec_all(tail(values))


'''
	Задача 2. Напишите рекурсивную функцию rec_all,
	которая бы являлась полнымэквивалентом функции all

	На вход подается список, и my_any вернет True, если
	хотя бы один элемент в списке логически соответствуют True.

	Подсказка: Если данный список пуст, в нем нет True-элементов,
	то есть хотя бы одного утверждения, поэтому результатом
	функции my_any от пустого списка будет False.
'''
def rec_any(values):
	if base_case(values):
		return False
	else:
		return bool(head(values)) or rec_any(tail(values))


'''
	Представляю вашему вниманию функцию cons, 
	которая принимает список и некий элемент.
	Функция cons возвращает идентичный список, но с добавленным в начало 
	данным элементом. Иначе говоря приклеивает ему новую голову.
	Функция возвращает новый список, а не изменяет исходный

	например cons(1, [2, 3]) --> [1, 2, 3]

	Функция пригодится в дальнейших задачах
'''
def cons(element, elements):
	new_list = elements.copy()
	new_list.insert(0, element)
	return new_list


'''
	Задача 3. Напишите рекурсивную функцию rec_take,

	На вход подается список, а также число, которое означает, сколько
	первых элементов нужно взять. Результатом функции будет список,
	в котором находятся первые несколько элементов исходного списка,
	причем столько, сколько указано в первом аргументе.

	Нельзя использовать фунукцию len и даже rec_len.

	Подсказка: Если в списке меньше элементов, чем
	сказано взять, то мы возвращаем столько элементов,
	сколько получилось взять.
'''
def rec_take(amount, values):
	if base_case(values) or amount == 0:
		return []
	else:
		return cons(head(values), rec_take(amount - 1, tail(values)))


'''
	Задача 4. Напишите рекурсивную функцию rec_drop,

	На вход подается список, а также число, которое означает, сколько
	первых элементов нужно отбросить. Результатом функции будет список,
	в котором находятся оставшиеся элементы, кроме первых нескольких элементов
	исходного списка, которых столько, сколько указано в первом аргументе.

	Нельзя использовать фунукцию len и даже rec_len.

	Подсказка: Если в списке меньше элементов, чем
	сказано отбросить, то мы возвращаем пустой список,
	ибо больше нечего отбрасывать.
'''
def rec_drop(amount, values):
	if base_case(values):
		return []
	elif amount == 0:
		return values
	else:
		return rec_drop(amount - 1, tail(values))


'''
	Задача 5. Немного отдохнем от рекурсии. Используя функции rec_drop
	и rec_take, напишите функцию naive_split_at, которая получает
	вторым аргументом список и разделяет его на две части. Разделение 
	должно происходить на позиции, данное в первом аргументе.
	
	Результатом выполнения функции naive_split_at должна быть пара из
	двух списков: взятые первые несколько элементов и все оставшиеся.

	Подсказка: Чтобы вернуть пару списков, то есть кортеж (tuple), можно
	в инструкции return использовать запятую. например

		return a, b
'''
def naive_split_at(index, some_list):
	return rec_take(index, some_list), rec_drop(index, some_list)


'''
	Задача 6. Напишите функцию rec_split_at, которая является более 
    эффективной версией функции naive_split_at. Более эффективной потому,
    что онп делает только один обход списка, и, таким образом, 
    не выполняет одну и ту же работу дважды.

    Подсказка, поскольку результатом функции rec_split_at является
    пара списков, то ее результаты можо распаковать с помощью
    кортежного присваивания значений переменных.

        Например как тут:

        x, y = rec_split_at(...)
'''
def rec_split_at(index, some_list):
    if base_case(some_list):
        return [], []
    else:
        if index == 0:
            return [], some_list
        else:
            before, after = rec_split_at(index - 1, tail(some_list))
            return cons(head(some_list), before), after
            

'''
    Задача 7. Напишите функию rec_range(...), которая является эквивалентом
    list(range(...)), то есть взвращает список диапазона.

    Не нужно волноваться об аргументах, будем считать, что всегда отправлсяют
    все три аргумента.

    Необходимо учесть, что шаг range может быть отрицательным и нельзя,
    чтобы он был нулевой.
'''
def rec_range(start, stop, step):
    if step == 0:
        raise ValueError("Нельзя иметь нулевой шаг в диапазоне")
    if start >= stop and step > 0 or start <= stop and step < 0:
        return []
    else:
        return cons(start, rec_range(start + step, stop, step))

 
'''
    Задача 8. Напишите рекурсивную версию функции map, которая принимает
    в качестве аргументов функцию f, а также список values. rec_map должна
    применить функцию f к каждому элементу списка values, после чего вернуть
    список результатов функции f.
'''           
def rec_map(f, values):
    if base_case(values):
        return []
    else:
        return cons(f(head(values)), rec_map(f, tail(values)))
        

'''
    Задача 9. Напишите рекурсивную версию функции filter, которая принимает
    в качестве аргументов функцию-предикат p, а также список values. rec_filter должна
    применить функцию-предикат p к каждому элементу списка values, после чего вернуть
    список исходных значений values, для который функция-предикат p выполняется, то есть
    сводится к True.

    Подсказка: Эквивалентный способ описать функцию
    filter(p, values) это [value for value in values if p(value)]
''' 
def rec_filter(p, values):
    if base_case(values):
        return []
    else:
        h = head(values)
        if p(h):
            return cons(h, rec_filter(p, tail(values)))
        else:
            return rec_filter(p, tail(values))
