STR_SOMETHING = ""
STR_SOMETHING_ELSE = ""
INT_SOMETHING = 0
INT_SOMETHING_ELSE = 0


'''
	Добро пожаловать в модуль, посвященный изучению рекурсии!

	В даном модуле мы научимся использовать рекурсию,
	начиная от более простых примеров, к более сложным.

	В этом модуле нельзя пользоваться арифметическими операциями,
	Зато можно использовать две данные функции succ(n) и pred(n),
	Чтобы прибавлять или вычитать единичку из числа.

	Такой ограниченный набор возможностей позволит лучше овладеть темой.
	Более того, сами числа в этом модуле будут восприниматься несколько иначе.

	Например числа 0, 1, 2, 3, ..., n будут представлены следующим образом:

			0 --> 0
			1 --> succ(0)
			2 --> succ(succ(0))
			3 --> succ(succ(succ(0)))
			...
			n --> succ(succ(succ(...succ(succ(0))...)))

	Уже на данном этапе проглядывается рекурсивность натуральных чисел.
	Это называется арифметика Пеано, в честь итальянского математика Джузеппе Пеано.

	Только базовые операции succ(n) и pred(n) имеют право использовать
	операторы `+` и `-` для чисел. Можно использовать операторы сравнения.
	Дальнейшие операции, такие как сложение и умножение,
	нужно реализовать с помощью succ(n) и pred(n).
	Использовать `+` для склеивания строк можно и даже нужно.
'''
def succ(n):
	return n + 1


def pred(n):
	if n <= 0:
		raise ValueError(
			"Не бывает натуральных чисел меньше нуля!")
	else:
		return n - 1


'''
	Задача 1. Для разминки. Реализовать функцию peano_str(n),
	преобразующую данное целое число n в строку,
	которая будет являться представлением числа в арифметике Пеано.

	Например:
		
		0 --> "0"
		1 --> "succ(0)"
		2 --> "succ(succ(0))"
		3 --> "succ(succ(succ(0)))"

		и так далее...

	Функция peano_str уже написана частично. 
	Ее необходимо дополнить.
'''
def peano_str(n):
	if n == 0:
		return STR_SOMETHING
	else:
		return "succ(" + STR_SOMETHING_ELSE + ")"


'''
	Задача 2. Реализация сложения с помощью succ(n),
	pred(n) и рекурсивного вызова самой функции peano_add

	Тут важно понимать, что истинной являются выражения:

		0 + m == m
		n + m == 1 + ((n - 1) + m)

	Функция peano_add уже написана частично. 
	Ее необходимо дополнить.
'''
def peano_add(n, m):
	if n == 0:
		return INT_SOMETHING
	else:
		return succ(INT_SOMETHING_ELSE)


'''
	Задача 3. Реализация вычитания с помощью
	pred(n) и рекурсивного вызова самой функции peano_sub

	Тут важно понимать, что истинной являются выражения:

		n - 0 == n
		n - m == (n - (m - 1)) - 1 

		или можно также воспользоваться свойствами,
		приведенными ниже, но лучше пользоваться одной парой свойств:

		n - n == 0
		n - m == 1 + (n - (m + 1))

	Разрешено допускать, что уменьшаемое число n 
	будет всегда больше, чем вычитатель m.
'''
def peano_sub(n, m):
	return 0


'''
	Задача 4. Реализация умножения с помощью
	pred(n) и рекурсивного вызова. Можно и даже нужно 
	пользоваться ранее написаной функцией peano_add(n, m)

	Тут важно понимать, что истинной являются выражения:

		0 x m == 0
		n x m == ((n - 1) x m) + m
'''
def peano_mul(n, m):
	return 0


'''
	Задача 5. Реализация целочисленного деления с помощью
	pred(n) и рекурсивного вызова. Можно и даже нужно 
	пользоваться ранее написаной функцией peano_sub(n, m)

	Тут важно понимать, что истинной являются выражения:

		0 / m == 0
		n / m == ((n - m) / m) + 1 

	А также:

		n / 0 нельзя! необходимо вызвать исключение 
		(ZeroDivisionError)	
'''
def peano_div(n, m):
	return 0


'''
	Задача 6. Небольшая передышка от рекурсии
	Реализация взятия остатка при делении двух чисел
	Можно использовать любые предыдущие функции.

	Тут важно понимать, что истинной являются выражения:

		n % m = n - (m x (n / m))

	А также:

		n % 0 нельзя! необходимо вызвать исключение 
		(ZeroDivisionError)	
'''
def peano_mod(n, m):
	return 0


'''
	Задача 7. Реализация возведения в степень с помощью
	pred(n) и рекурсивного вызова.

	Тут важно понимать, что истинной являются выражения:

		n ** 0 == 1
		n ** m == n x (n ** (m - 1))
'''
def peano_pow(n, m):
	return 0
